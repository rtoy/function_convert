\documentclass[12pt,fleqn]{extarticle}


% Enable a table of contents
\setcounter{tocdepth}{2}   % sections and subsections
\setcounter{secnumdepth}{2}

% Optional: add the ToC to the PDF bookmarks if using hyperref
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  urlcolor=blue,
  citecolor=black,
  pdfborder={0 0 0}
}

% --- Page layout ---

\usepackage{setspace}        % Optional: adjust line spacing
\setstretch{1.08}
\usepackage[margin=0.75in]{geometry}
% --- Fonts ---
%\usepackage{tgtermes}        % Modern serif text font (TeX Gyre Termes)
\usepackage{newtxtext}
\usepackage{newtxmath}       % Matching math font with good coverage


\usepackage{enumitem}
\setlist[itemize]{itemsep=2pt, topsep=2pt, parsep=0pt, partopsep=0pt}



% --- General utilities ---
%\usepackage{amsmath}
\usepackage{mathtools}

\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{upgreek}

\newcommand{\ttq}[1]{\texttt{`#1'}}

\DeclareRobustCommand{\funconvert}{\texttt{function\kern0.21em convert}\hspace{0.2em}}
% --- Section styling (optional, but elegant) ---
\usepackage{titlesec}
\titleformat{\section}{\large\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}{\normalsize\bfseries}{\thesubsection}{1em}{}


\usepackage{tcolorbox}
\tcbuselibrary{skins, breakable}
\tcbuselibrary{listings}

\newenvironment{maximabox}
  {\begin{tcolorbox}[
      breakable,
      enhanced,
      colback=black!2,
      colframe=black!50,
      boxrule=0.4pt,
      arc=2pt,
      left=6pt,
      right=6pt,
      top=6pt,
      bottom=6pt,
      before skip=10pt,
      after skip=10pt
    ]}
  {\end{tcolorbox}}


\DeclareMathOperator{\erf}{erf}
\DeclareMathOperator{\erfc}{erfc}
\DeclareMathOperator{\erfi}{erfi}
\DeclareMathOperator{\signum}{signum}
%magic for formatting for the bib
\usepackage{etoolbox}
\apptocmd{\thebibliography}{\raggedright}{}{}
% --- Microtypography ---
\usepackage[final,tracking=true,kerning=true,spacing=true]{microtype}
% --- Metadata ---
\title{Writing Converters for the Function Convert Package}
\author{Barton Willis}
\date{\today}


\begin{document}
\maketitle
\tableofcontents


\section{Introduction and prerequisites}

Maxima’s \funconvert package~\cite{willis-function-convert} performs semantic function‑to‑function conversions on Maxima~\cite{maxima} expressions. This tutorial explains how to extend the package’s mathematical capabilities by writing your own converters. To follow this tutorial, you should be comfortable with:
\begin{itemize} \item using Maxima and the \funconvert package, and 
\item programming Maxima in Common Lisp. 
\end{itemize}
This guide is written for people who want to create new converters. It focuses on the writing converters: patterns, idioms, and design principles.  Here we include only the API elements that matter when you are authoring a converter.

To install this package, place the file \ttq{file\_convert.lisp} in a directory on Maxima’s search path and load it with  \ttq{load("function\_convert");}.  Eventually, this package might be migrated to 
Maxima's /src folder--when this happens, loading the package will not be needed.

We begin with the basic usage of the \funconvert package and an overview of its main features.

\paragraph*{Source Note} Portions of this tutorial are taken from, or adapted from, the project’s \texttt{README.md} on GitHub~\cite{willis-function-convert}, with the permission of the author.


\section{Usage and Features}

The most basic use of the package is a converter that replaces each subexpression of a Maxima expression of the form  $\erfc(X)$  with by $1 - \erf(X)$, where  and  are the error functions and 
$X$ may be any expression. This converter is built into the \funconvert package. To use it, enter:
\begin{maximabox}
\begin{verbatim}
(%i1) function_convert(erfc = erf, erfc(x));
(%o1)                             1 - erf(x)
\end{verbatim}
\end{maximabox} 
\noindent  Of course, the input can be any expression, including nested calls to $\erf$; for 
example
\begin{maximabox}
\begin{verbatim}
(%i2) function_convert(erfc = erf, x*erfc(x + erfc(z)));
(%o2)                     x (erf(erf(z) - x - 1) + 1)
\end{verbatim}
\end{maximabox} 
The first argument \ttq{erfc = erf} is called a \emph{conversion rule} (or simply a `rule'), the left-hand side
is the \emph{source function} and the right-hand side \ttq{erf} is called  the
\emph{target function}. The rule \ttq{erfc = erf} does not literally
replace the source function with the target function, but it instead applies the 
identity $\erfc(x) = 1 - \erf(x)$ to an expression, replacing the left side with 
the right side. 

The name of the target function is best thought of a mnemonic for recalling 
the identity $\erfc(x) = 1 - \erf(x)$, not as a literal function. Actually, the name of the 
target function could be any Maxima symbol; for example, the rule could be named 
\ttq{erfc = erfc\_to\_erf}.

\subsection{Algorithm and Implementation}

The function \texttt{function\_convert} walks an expression tree and replaces function calls according to well‑defined rules. In that sense, it is straightforward code of a kind repeated many times in Maxima. It is not a pattern matcher or a general rewrite engine.

The package is implemented in Common Lisp. It has been tested using Clozure Common Lisp~\cite{ccl} version 1.13 and SBCL~\cite{sbcl} version 2.4.7.

\subsection{Naming and the Alias System}

We've seen that the name of the target function is best thought of an alias for the identity being 
applied.  The \funconvert package has an alias system allows the source function to be a
mnemonic as well.  This feature is useful for naming a converter for an identity 
such as 
\begin{equation}
\Gamma\left(z\right)\Gamma\left(1-z\right)=\uppi/\sin\left(\uppi z\right). \label{gammaid}
\end{equation}
Here the left-hand-side of this identity is a product, so the source function for this identity must be multiplication (internally \ttq{mtimes}), not the gamma function. But the rule \texttt{”*” = sin} is
hard to remember and unnatural.  The alias system allows the converter for this identity to have a much more natural name. For the identity in Eq. (\ref{gammaid}), using the alias system we can 
name this rule \ttq{gamma = sin}. Actually, this converter  built-in to the \funconvert package:

\begin{maximabox}
\begin{verbatim}
(%i1) function_convert(gamma = sin, gamma(x)*gamma(1-x));
(%o1) %pi/sin(%pi*x)

(%i2) function_convert(gamma = sin, gamma(2 + x)*gamma(1-x));
(%o2) gamma(1-x)*gamma(x+2)
\end{verbatim}
\end{maximabox}

A macro takes care of the messy details of defining an alias, along with other housekeeping duties. 
 
 
 \subsection{Built-in converters}

A converter may be marked as built-in. Built-in converters cannot be removed using any user-level function. For example, the converter \ttq{erfc = erf} is built-in; attempting to remove it with \ttq{delete\_converter} produces an error:
\begin{maximabox}
\begin{verbatim}
(%i1) delete_converter(erfc = erf);
Cannot delete built-in converter (%ERFC → %ERF).
\end{verbatim}
\end{maximabox}
 
 
 \subsection{Self-documentation feature}
 
 Every converter function should have a doc string.  The doc string is available to the user
 via the function \texttt{describe\_converter}; for example
\begin{maximabox}
  \begin{verbatim}
    (%i1) describe_converter(sinc = sin);
Converter: %SINC = %SIN
Function: #<FUNCTION FUNCTION-CONVERTER-%SINC-%SIN>
Type: built-in

Docstring:
  Convert sinc(x) into sin(x)/x.
  \end{verbatim}
\end{maximabox}
If a user-package properly includes a doc string for a converter, that documentation will
be available via the function \ttq{describe\_converter} once the package is loaded.  
The name of the converter, in this case \ttq{FUNCTION-CONVERTER-\%SINC-\%SIN}, is
automatically generated by a macro that is used to define a converter--the function name
of a converted is unlikely to be useful to a user.

\subsection{Class Keys and Class-Based Dispatch}

Converter functions often need to apply the same transformation to an entire
family of related operators. For example, a converter that rewrites
trigonometric functions into exponential functions should apply uniformly to
all six trigonometric functions. Writing six separate converters is tedious and 
error-prone. The \emph{class key} mechanism provides a solution.

\paragraph{Purpose of Class Keys} A \emph{class key} is a symbolic tag (such as \texttt{:trig} or
\texttt{:hyperbolic}) that represents a category of operators. The converter
system uses these tags to perform \emph{class-based dispatch}: a single
converter registered for a class key is automatically applied to every
operator belonging to that class.

Class keys classify operators, not expression types. For example, the class
\texttt{:algebraic} contains the operators \texttt{mplus}, \texttt{mtimes}, and \texttt{mexpt}.
But if the head operator of an expression belongs to the class \texttt{:algebraic}, that does not imply that the expression itself is algebraic.

\paragraph{The Class Table} The mapping from class keys to operators resides in the 
global \texttt{*converter-class-table*}. This table is 

\begin{maximabox}
\begin{verbatim}
(defparameter *converter-class-table*
  '((:trig        . (%sin %cos %tan %sec %csc %cot))
    (:hyperbolic  . (%sinh %cosh %tanh %sech %csch %coth))
    (:inv_trig    . (%asin %acos %atan %asec %acsc %acot))
    (:inv_hyperbolic . (%asinh %acosh %atanh %asech %acsch %acoth))
    (:exp            . (mexpt))
    (:gamma_like     . (%gamma %beta %binomial %double_factorial
                        mfactorial $pochhammer))
    (:bessel  . (%bessel_j %bessel_y %bessel_i %bessel_k
                 %hankel_1 %hankel_2 %airy_ai %airy_bi
                 %airy_dai %airy_dbi))
    (:algebraic . (mplus mtimes mexpt))
    (:inequation . (mequal mlessp mleqp mnotequal mgreaterp mgeqp
                    $notequal $equal))
    (:logarithmic . (%log)))
  "Mapping from class keys to lists of operator symbols.")
\end{verbatim}
\end{maximabox}
Each entry associates a class key with the list of operators that belong to
that class. The system assumes that \emph{an operator belongs to exactly one class}.
This ensures unambiguous dispatch: when the converter system encounters an
operator, it can determine its class uniquely and apply the appropriate
class-level converter.

\paragraph{How Class Dispatch Works} When the converter system processes an expression, it identifies the operator at the head of the form. It then:
\begin{enumerate}[label=(\alph*), noitemsep, topsep=0pt]
  \item looks up the operator in \texttt{*converter-class-table*};
  \item determines the corresponding class key (e.g., \texttt{:trig});
  \item checks whether a converter is registered for that class;
  \item if so, applies that converter to the entire expression.
\end{enumerate}

\paragraph{Why Class Keys Matter} Class keys provide:
\begin{itemize}
  \item \textbf{Abstraction}: one converter per conceptual family.
  \item \textbf{Extensibility}: adding a new operator to a class requires no
        changes to existing converters.
  \item \textbf{Uniformity}: guarantees consistent behavior across related
        operators.
  \item \textbf{Clarity}: the class table documents the structure of the
        operator space.
\end{itemize}

\subsection{Chaining multiple conversions}
To apply two or more conversions, put the converters into a list; for example

\begin{maximabox}
\begin{verbatim}
(%i1) function_convert(['sinc = 'sin, 'sin = 'exp], sinc(x)^2);
(%o1) -((%e^(%i*x)-%e^-(%i*x))^2/(4*x^2))
\end{verbatim}
\end{maximabox}
\noindent Converters are applied left-to-right. 

Chaining multiple conversions is handled by the function \texttt{function\_convert}; a writer of
a converter doesn't need to do anything to allow chaining to work. 

\subsection{Implicit Dispatch via Breadth-First Search}

The converter system automatically discovers multistep conversion chains.
For example, if a converter is defined from $f$ to $g$ and another from
$g$ to $h$, the system is able to convert $f$ to $h$ without any
additional user-defined rule. In other words, there is no need to define a
direct converter $f$ to $h$.

This behavior is enabled by a breadth-first search (BFS) over the converter
graph. The search locates the shortest available path between two operators
and composes the corresponding converters.  Writers of converters only need
to know that \funconvert uses BFS, not anything about the internals of this
mechanism.

\subsection{Errors and Debugging}

When a converter is redefined, Maxima will issue a warning, and when a converter
doesn't exist,  Maxima returns the input unchanged, but doesn't issue a warning; 
for example
\begin{maximabox}
\begin{verbatim}
(%i2) function_convert(f = g, a+b);
(%o2)                                b + a
\end{verbatim}
\end{maximabox}

When writing a new converter, if a converter doesn't trigger, the problem is likely due to either
a typo or some confusion between Maxima nouns and verbs. If a converter that doesn't trigger 
correctly, try tracing the Common Lisp function \texttt{lookup-converter}. From there, you 
might be able to diagnose the problem.

\section{Writing converter functions}
A macro \texttt{define-function-converter} takes care of many of the housekeeping 
details in writing a converter, including naming the internal function that applies the rule, 
optionally marking the converter as built-in, and gathering the doc string 
for the converter to use a user-documentation. The macro also automatically handles 
the details needed to make the alias system work. 

The function \texttt{function\_convert} does the work of mapping
the converter over the expression tree; this allows the converter code to be relatively simple.
We'll begin by examining the source code of the \ttq{erfc = erf} converter.

\subsection{The $\erfc$ to $\erf$ converter}

 The source code for the $\erfc$ to $\erf$ converter is 
\begin{maximabox}
\begin{verbatim}
(define-function-converter (%erfc %erf) (op x)
    :builtin
  "Convert erfc(x) into 1 - erf(x)."
  (declare (ignore op))
  (let ((z (car x)))
    (sub 1 (ftake '%erf z))))
\end{verbatim}
\end{maximabox}
The arguments \ttq{\%erf \%erfc} are the source and target functions, 
respectively.  For this converter, the argument \ttq{op} is bound to the source
function \ttq{\%erfc}, but  this converter doesn't use this argument, so the
converter code should declare to ignore it.  The argument \ttq{x} is
a Common Lisp list of the argument to the function \ttq{\%erfc}.

The optional keyword argument  \ttq{:builtin} declares that this converter cannot be
deleted using user-level functions. To mark a rule as built-in, the keyword \ttq{:builtin}  must be placed before the doc string. For a non-built-in rule,  omit the  \ttq{:builtin} keyword.
The doc string is optional, but important because supplies the converter with documentation. 

The mathematical part of the code, that is
\begin{maximabox}
\begin{verbatim}
  (let ((z (car x)))
    (sub 1 (ftake '%erf z)))
\end{verbatim}
\end{maximabox}
\noindent implements the identity $\erfc(x) = 1 - \erf(x)$.  Notice that since \texttt{x} is a Common Lisp list
of the argument to \texttt{\%erfc}, it is necessary to apply \texttt{\%erf} to the car of \texttt{x}, and
not to \texttt{x} itself.  Alternatively, if you prefer, this bit of code can be changed to 
\begin{maximabox}
\begin{verbatim}
      (sub 1 (fapply '%erf x))
\end{verbatim}
\end{maximabox}

\subsection{Alias Dispatch}

As we discussed before, both the source and the target functions of a converter can be given an alias.  This can be useful when the actual source function is a poor mnemonic for the converter name.

Again, the macro \ttq{define-function-converter} takes care of the housekeeping 
for defining an alias.  The best way to explain how to use alias dispatch is by an 
example.  Here we give a converter that expands explicit powers, but not 
products of sums.  The source function must be \ttq{mexpt}, but we'll make
\ttq{power = expand} an alias for \verb|”^” = expand|. This is how it is done:
\begin{maximabox}
\begin{verbatim}
(define-function-converter ((mexpt $expand) ($power $expand)) (op x)
  ($expand (fapply 'mexpt x)))
\end{verbatim}
\end{maximabox}
\noindent A rule can have at most one alias.

There are two ways to invoke this converter:
\begin{maximabox}
\begin{verbatim}
(%i1) function_convert("^" = expand, (a+b)*x + (1+x)^2);
(%o1) x^2+(b+a)*x+2*x+1

(%i2) function_convert(power = expand_powers, (a+b)*x + (1+x)^2);
(%o2) x^2+(b+a)*x+2*x+1
\end{verbatim}
\end{maximabox}

\subsection{Class Key Converter Dispatch}

Class-key converters allow a single definition to handle an entire family of
related operators, for example all trigonometric functions. The following example 
illustrates this idea using the trigonometric class \texttt{:trig}. Any operator listed under the
\texttt{:trig} class key in \texttt{*converter-class-table*} will be handled
by the same converter, without the need to define six separate rules. 

Specifically,  we'll show how to define a rule that rewrites all trigonometric functions in terms of sine
and cosine. For this converter, we finally have a reason for the \ttq{op} argument--this
argument will be bound to one of the six trigonometric functions.  The
main code uses a \ttq{case} statement to handle each of the six cases. The code is

\begin{maximabox}
\begin{verbatim}
(define-function-converter (:trig $sin_cos) (op x)
  :builtin
  ;; Convert all six trigonometric functions to sin/cos form.
  (let ((z (first x)))
    (case op
      (%sin (ftake '%sin z))
      (%cos (ftake '%cos z))
      (%tan (div (ftake '%sin z) (ftake '%cos z)))
      (%sec (div 1 (ftake '%cos z)))
      (%csc (div 1 (ftake '%sin z)))
      (%cot (div (ftake '%cos z) (ftake '%sin z)))
      (t (ftake op z)))))
\end{verbatim}
\end{maximabox}
This converter is registered for the class key \ttq{:trig}, not for any
individual operator. When the dispatch system encounters an expression such as
\texttt{((\%tan) x)} or \texttt{((\%csc) x)}, it determines that the operator
belongs to the \ttq{:trig} class and invokes the converter above.

The body of the converter receives two arguments: the operator \ttq{op}
and its argument list \ttq{x}. The converter then rewrites each
trigonometric function into its sine--cosine form. Because the class key
handles the grouping, the converter itself contains only the mathematical
logic; it does not need to know how many operators belong to the class or
where they appear in the system.

\subsection{A more advanced converter}

In this section, we show to to build a converter that rewrites explicit products of the form
$x  \signum(x)$ as $|x|$.   The converter does not rewrite 
\(\mathrm{signum}(x)\) itself, because the pattern \(x \signum(x)\) is 
not a subexpression of \(\signum(x)\); only explicit products matching that pattern
are transformed--this is what makes writing the converter somewhat tricky.  The converter logic
needs to scan the arguments of each product and gather the terms that have $\signum$
as their head operator.  For each of these terms,  the converter does a rational substitution (\ttq{ratsimp}) of the form \ttq{ratsubst(abs(s), s*signum(s), e)} on the expression \ttq{e},
that must be a product. The definition is:

\begin{maximabox}
\begin{verbatim}
(define-function-converter ((mtimes mabs) (%signum mabs)) (op x)
  :builtin
  "Convert subexpressions of the form X*signum(X) into abs(X).  This converter
does not rewrite signum(X) itself, since X*signum(X) is not a subexpression
of signum(X); only explicit products matching that pattern are transformed."
  (let* ((e  (fapply op x))
         (ll (xgather-args-of e '%signum)))
    (dolist (lx ll)
      (let ((s (car lx)))
        (setq e ($ratsubst (ftake 'mabs s)
                           (mul s (ftake '%signum s))
                           e))))
    ($expand e 0 0)))
\end{verbatim}
\end{maximabox}

\subsection*{How the converter works}

\begin{enumerate}[label=(\alph*), noitemsep, topsep=0pt]
  \item The converter receives the head operator \texttt{op} and its
        argument list \texttt{x}.  The call \texttt{(fapply op x)}
        reconstructs the full expression  \ttq{e}.

  \item The function \ttq{xgather-args-of} scans \ttq{e}. for
        occurrences of \ttq{\%signum} and returns a list of matches.
        Each element of this list contains the argument \(X\) of a
        subexpression \(\mathrm{signum}(X)\). The \funconvert
        package defines the function \ttq{xgather-args-of}.

  \item For each such argument \(s\), the converter constructs the
        product \(s \cdot \mathrm{signum}(s)\) and replaces it with
        \(\mathrm{abs}(s)\) using \ttq{ratsubst}.  Only explicit
        products are rewritten; no algebraic inference is performed.

  \item After all substitutions, the expression is resimplified with a
        call to \ttq{expand}.
\end{enumerate}

This converter is intentionally conservative: it rewrites only the
literal pattern \(X  \signum(X)\), never the function
\(\mathrm{signum}\) itself.

\section{Best Practices for Writing Converters}

 The guidelines below help ensure that new converters integrate smoothly into
the \funconvert system.

\begin{itemize}

  \item \textbf{Base converters on identities.}
        A converter should be based on a mathematical identity.
        It should not change the meaning of an expression outside its
        intended domain. If a transformation is only valid under certain
        assumptions, the converter should check them explicitly or decline
        to apply the transformation. It is discouraged, but possible, to
        write a converter that, for example, replaces every product by the
        number~42.

  \item \textbf{Include a doc string.}
        Each converter should have a doc string so that \funconvert is
        self-documenting. If a converter requires a domain restriction or
        mathematical convention, document it. Clear documentation prevents
        misuse and helps future contributors maintain the system.

  \item \textbf{Use clear, descriptive names.}
        Converter names or aliases should reflect the mathematical
        transformation they perform. This helps users understand the
        converter registry and simplifies debugging.

  \item \textbf{Keep converters small and focused.}
        A converter should perform one clear transformation, such as
        rewriting \(\erfc(x)\) as \(1 - \erf(x)\) or converting
        \(\tan(x)\) to \(\sin(x)/\cos(x)\). Small, focused converters
        compose more reliably and are easier to test and debug.

  \item \textbf{Dispatch on functions, not patterns.}
        Converters operate on function calls, not syntactic patterns. Let
        the converter receive the arguments directly and compute the
        replacement semantically. This avoids brittle rules and reduces
        unintended matches.

  \item \textbf{Ensure termination.}
        Converters should not create expressions that trigger themselves
        again unless the transformation is guaranteed to converge.

  \item \textbf{Write regression tests.}
        Each converter should have regression tests covering typical
        inputs, edge cases, and expressions where the converter should
        \emph{not} apply. Tests help maintain stability as the system
        evolves.

\end{itemize}




\section{Miscellaneous}

We end with a few comments about the \funconvert package that are not directly related to the process of writing converter functions.

\subsection {Motivation} 

Many systems (Maple~\cite{maple-convert}, Mathematica~\cite{mathematica-rules}, SymPy~\cite{sympy-rewrite}) provide built‑in expansions or rewrite mechanisms, but Maxima uses an alphabet soup of 
functions that perform semantic function‑to‑function conversions; examples include  \ttq{makefact}
and \ttq{makegamma}. In other cases, transformations are controlled by option variables—for example, 
\ttq{expintrep}. 

These names are easy to forget and are not always easy to locate in the user documentation. 
The \funconvert package may offer a simple, uniform, and user‑extensible way to perform such conversions.

\subsection{Using  \ttq{defrule} as an alternative to \funconvert}

Maxima's pattern-based \ttq{defrule} tool is an alternative to using \funconvert. A simple
example: 
\begin{maximabox}
\begin{verbatim}
(%i1) matchdeclare(aa,true)$

(%i2) defrule(sinc_rule, sinc(aa), sin(aa)/aa);
(%o2) sinc_rule:marrow(sinc(aa),sin(aa)/aa)

(%i3) apply1(sinc(sinc(x)), sinc_rule);
(%o3) (x*sin(sin(x)/x))/sin(x)
\end{verbatim}
\end{maximabox}
This method works well, especially for single use function-to-function conversions. But a \ttq{kill(all)} removes all rules defined by 
\ttq{defrule} and it still relies on an alphabet soup of functions.  Changing
Maxima to allow rules that cannot be removed by \ttq{kill(all)} is, of course, a 
small matter of programming~\cite{nardi-small-matter},
but  it would violate a long‑standing design principle that users must always be able to return the system to a clean, rule‑free state.

Additionally, it is difficult to define rules that need to match two or more terms in a sum or 
product.  The \funconvert package has several converters that do just that.  Often these 
converters internally rely on \texttt{ratsubst} to do semantic substitutions--something
that is difficult for a rule defined by \ttq{defrule} to do.
Finally, the package has at least one built-in rule that is difficult to fully duplicate using 
\ttq{defrule}: 
\begin{maximabox}
\begin{verbatim}
(%i1) function_convert('gamma = 'sin, 20252*x*gamma(x)*gamma(1-x) < %pi);
(%o1) (20252*%pi*x)/sin(%pi*x) < %pi
\end{verbatim}
\end{maximabox}



\paragraph*{About the Author}
This manual was written by Barton Willis, a long-time contributor to the
Maxima computer algebra system and the author of the \funconvert package.
He has worked with symbolic computation, mathematical software, and
technical documentation for many years.

\paragraph*{Colophon} This manual was typeset using the \texttt{pdflatex} engine with the
\texttt{extarticle} document class. The body text is set in a serif typeface chosen for
clarity in extended technical prose. Code fragments and Maxima sessions
are rendered in a monospaced font with consistent verbatim handling. Bibliographic data were managed using \texttt{bibtex} using the \texttt{IEEEtran} style.

All examples were executed using Maxima from the current development branch together with the \funconvert package also from the current development branch.

Portions of this document were adapted from the project's
\texttt{README.md} on GitHub, with the permission of the author.


This manual is intended as a long-term reference for users and
developers who wish to extend the mathematical capabilities of the
\funconvert package by writing custom converters.

\bibliographystyle{IEEEtran}
\bibliography{references}


\end{document} 

Sections I might include 

- Quick Start
- Conceptual Overview

- Error Handling and Debugging
- Regression tests
- Appendix: Built‑In Converters
- API of all public functions

-Error Handling and Debugging:
- common mistakes,
- how to interpret converter warnings,
- debugging tools or strategies,
- how to inspect the converter registry.



